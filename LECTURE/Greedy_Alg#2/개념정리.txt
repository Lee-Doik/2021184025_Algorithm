Greedy Algorighm #2

-Dijkstra

	다익스트라 알고리즘은 다이나믹 프로그래밍을 활용한 대표적인 최단경로 탐색 알고리즘이다.

	특정한 하나의 정점에서 다른 모든 정점으로 가는 최단경로를 알려준다.

	이때, 음의 간선을 포함할 수 없다. 따라서 현실 세계에 사용하기 매우 적합한 알고리즘.

	최단 거리는 여러개의 최단 거리로 이루어져있기 때문에 다이나믹 프로그래밍이다.

	기본적으로 다익스트라는 하나의 최단거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다는 특징이 있다.

	'현재까지 알고 있던 최단 경로를 계속해서 갱신한다'

	1. 출발 노드를 설정합니다.
	2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장합니다.
	3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택합니다.
	4. 해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신합니다.
	5. 위 과정 중 3-4 번을 반복한다.

	선형 탐색 구조로 알고리즘을 구현할 경우 시간 복잡도는 O(N^^2)이다.

	힙 구조 사용 시 시간복잡도는 O(N*logN)이 될 수 있다.


-Knapsack
	
	부분 배낭 문제 中 분수 배낭 문제

	배낭에 물건을 넣을 때 이윤을 최대로 낼 수 있는 방법

	단위무게당 이윤이 제일 큰 물건을 다 채우고, 그 다음 단위 무게당 이윤이 큰 물건을 채우고, 더 이상 하나의 물건 전체를 채울 수 없는 상태까지 채운 다음, 그 다음으로 단위 무게당 이윤이 큰 물건을 남아있는 배낭의 비율만큼 채우는 것이다.

	시간 복잡도는 O(N*logN)이다.(정렬 알고리즘의 시간복잡도)

-Set Cover

	집합 덮개 문제(set cover problem)는 전산학과 복잡도 이론에서 다루는 오랜 문제로, 어떠한 전체집합과 그 집합의 부분집합들이 주어졌을 때, 부분집합들 중에서 가능한 한 적은 집합을 골라서 그 집합들의 합집합이 원래 전체집합이 되도록, 즉 그 집합들이 원래 전제집합을 '덮도록' 집합을 선택하는 문제이다. 이때 집합을 가능한 한 적게 골라내는 것이 목표이다


-Job Scheduling

	기계에서 수행되는 n개의 작업 t1, t2, … tn이 있고, 각 작업은 시작시간과 종료시간이 있다.

	작업 스케줄링(Task Scheduling) 문제는 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정하는 문제이다.

	빠른 시작시간 우선
	빠른 종료시간 우선
	짧은 작업 우선 베정
	긴 작업 우선 배정 중의 방법에서, 빠른 시작시간 우선 알고리즘을 제외하면 나머지 알고리즘은 항상 최적해를 찾지 못한다.

	-psuedo code

	입력: n개의 작업 t1, t2, ... , tn
	출력: 각 기계에 배정된 작업 순서
	시작시간의 오름차순으로 정렬한 작업 리스트를 L이라고 한다.
	while (L ≠ ∅) {
	  L에서 가장 이른 시작시간을 가진 작업 ti를 가져온다.
	  if (ti를 수행할 기계가 있으면)
	    ti를 수행할 수 있는 기계에 배정한다.
	  else
	    새로운 기계에 ti를 배정한다.
	  ti를 L에서 제거한다.
	}
	return 각 기계에 배정된 작업 순서


-Huffman

	허프만 코딩은 텍스트 압축을 위해 널리 사용되는 방법으로, 원본 데이터에서 자주 출현하는 문자는 적은 비트의 코드로 변환하여 표현하고 출현 빈도가 낮은 문자는 많은 비트의 코드로 변환하여 표현함으로써 전체 데이터를 표현하는데 필요한 비트 수를 줄이는 방식이다.

	-허프만 트리 (Huffman Tree)

	1. 문자열을 입력 받는다.
	2. 입력받은 문자열을 문자 단위로 끊어 해시 맵에 저장한 뒤에 빈도수를 체크한다.
	3. 이후에 빈도수가 1 이상인 문자에 한해서 우선순위 큐에 삽입한다.
	4. 우선순위 큐에 삽입하면서 자동으로 빈도수라는 우선순위에 따라 최소 힙과 같은 형태가 된다.
	5. 루트 노드에서부터 순회하며 0 또는 1을 붙여 허프만 코딩 알고리즘을 적용한다.
	6. 결과적으로 처음 입력 받은 문자열을 해시 맵과 대조하여 압축된 2진형을 출력한다.