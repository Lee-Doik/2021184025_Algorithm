그래프

	정점(vertice)의 집합 V와 간선(edge)의 집합 E로 이루어진다.
	보통 (V,E)로 표현한다.

	각각의 간선은 두 정점의 쌍으로 나타낸다.

	간선에 방향이나 가중치가 부여되는 경우도 있다.

	방향 그래프(Directed), 무방향 그래프(Undirected) 

	트리는 그래프의 한 종류.

	방향 그래프에는 셀프 엣지라는 자신을 가리키는 노드가 있음.

	하나 이상의 사이클이 있으면 Cyclic graph, 
	하나도 없으면 Acyclic graph 이다.

	Adjacency Matrix : 2차원 배열에 그래프 표현.

	N X N 배열에 연결여부 확인을 하여 표현한다.

	Adjacency List : 연결리스트로 그래프 표현.

	서로의 연결 여부를 표현하기 때문에 2M개의 노드가 생긴다.

Union_Find 합집합 찾기.

	서로소 집합 알고리즘 이라고도 불린다.

	구체적으로 여러 개의 노드가 존재할 때 두개의 노드를 선택해서 
	현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.

	연결성에 대한 표현.

	예를 들어 1, 2, 3, 4, 5 의 정점이 있다고 가정해보자.

	이 노드들은 연결되어 있지 않다고 생각했을때, 

	각 노드들은 자기 자신을 가리킨다.

	노드 1, 2 가 연결되어 있다고 생각했을 때,

	노드 1은 자기 자신을 가리키고, 노드 2는 1을 가리킨다.

	이렇게 부모를 합칠 때는 일반적으로 더 작은 값 쪽으로 합친다.

	이를 '합침(Union)'이라고 한다.

	이때, 2와 3도 연결되었다고 생각하면 3은 2를 가리킨다.

	부모 노드만을 1과 3이 연결되었는지 확인이 불가능 하기 때문에

	재귀함수를 이용해 3과 연결된 2가 1과 연결되었는지 확인한다.

	Find 알고리즘은 두개의 노드의 부모 노드를 확인하여 현재 같은 집합에 속하는지 확인하는 알고리즘이다.

 MST

 	Kruscal algorithm

 		가장 적은 비용으로 모든 노드를 연결하기 위해 사용되는 알고리즘.

 		최소 비용 신장 트리.

 		간선 정보를 오름차순으로 정렬한 뒤에 비용이 적은 간선부터 그래프에 포함시킨다.

 		이때, 정렬된 순서에 맞게 그래프에 포함시킨다.

 		포함시키기 전, 사이클 테이블을 확인한다.

 		만약 사이클을 형성한다면, 간선을 그래프에 포함시키지 않는다.
 		(사이클의 발생여부는 UNION_Find 알고리즘을 이용한다)

 	Prim

 		신장 트리 (Spanning Tree)

 		모든 정점이 간선으로 연결되어 있으면서 사이클이 없는 그래프.

 		MST(Minimum Spanning Tree)

 		신장 트리 중에서 간선의 비용(가중치)의 합이 최소가 되는 것을 최소 신장 트리 라고 한다.

 		프림 알고리즘은 노드를 중심으로 간선을 탐색하는 방법이다.

 		시간 복잡도는  O(ElogV) 이다.

		1. 임의의 start 정점을 하난 선택하여 우선순위 큐에 넣는다.

		2. 우선순위 큐에서 정점을 하나 꺼낸다.
		(우선순위에 의해 비용이 가장 적은 정점이 우선순위 큐를 빠져나온다)

		3. 우선순위 큐에서 꺼낸 정점이 방문한적이 있으면 다시 새로운 정점을 꺼낸다.

		4. 우선순위 큐에서 꺼낸 정점이 아직 방문한 정점이 아니라면 방문처리를 하고 정점의 비용을 더한다.

		5. 위의 정점과 연결된 다른 정점들 중 방문하지 않은 정점들의 정보를 우선순위 큐에 넣는다.

		6.  우선순위 큐가 비어있을 때까지 2~5 과정을 반복한다.